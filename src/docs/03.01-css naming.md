### Namespacing
In no particular order, here are the individual namespaces and a brief description. We’ll look at each in more detail in a moment, but the following list should acquaint you with the kinds of thing we’re hoping to achieve.

- `o-`: Signify that something is a global object and may be used in any number of unrelated contexts to the one you can currently see it in. Making modifications to these types of class could potentially have knock-on effects in a lot of other unrelated places. Tread carefully.
- `c-`: Signify that something is a Component. This is a concrete, implementation-specific piece of UI. All of the changes you make to its styles should be detectable in the context you’re currently looking at. Modifying these styles should be safe and have no side effects.
- `u-`: Signify that this class is a Utility class. It has a very specific role (often providing only one declaration) and should not be bound onto or changed. It can be reused and is not tied to any specific piece of UI.
- `t-`: Signify that a class is responsible for adding a Theme to a view. It lets us know that UI Components’ current cosmetic appearance may be due to the presence of a theme.
- `is-`, `has-`: Signify that the piece of UI in question is currently styled a certain way because of a state or condition. This stateful namespace is gorgeous, and comes from [SMACSS](https://smacss.com/book/type-state). It tells us that the DOM currently has a temporary, optional, or short-lived style applied to it due to a certain state being invoked.
- `js-`: JavaScript namespaces are pretty common now, and most people tend to use them. The idea is that—in order to properly separate our concerns—we should never have styling and behaviour bound to the same hooks. To bind both technologies onto the same hook means we can’t have one without the other: our UI becomes all-or-nothing, which makes it very opinionated and inflexible.

### Our Approach (BEVM)
We follow a little bit modified version of BEM which solves some of the pains in BEM. BEVM (```block__element--variation -modifier```).

#### Variations (--variation)
We would like to avoid variations as much as possible. A variation would be defined as a different or distinct form or version of a block where we change a block on multiple levels in terms of size, color & layout etc. in the same class. Its mostly referred as **Single Class** approach in more classical BEM. For example we have a button block as below:

```html
<button class="o-btn" />
```

To create a variation of the 'btn' block we created a class 'btn--primary' as below:

```html
<button class="o-btn--primary" />
```
We do not repeating the base class like `btn btn--primary` and **SASS** we use `@extend` to share rules between the base and the variation. For example as below:

```css
.o-btn {
  background: $brand-alto-gray;
  border: 0;
  border-radius: 2px;
  font-size: 1.3rem;
  font-weight: 500;
  padding: 12px 24px;
}

.o-btn--primary {
  @extend .btn;
  background: $brand-red;
  background: $brand-gradient-red;
  color: $white;  
}
```
**Variation Rules**
1. Can only apply one "variation" at a time
2. No need to repeat base class name
3. Can use SASS `@extend` to share rules
4. Or a custom variation can be used without using `@extend`


#### Modifier (-modifier)
A modifier is an extension that makes a partial or minor change in the rule set of a block. So instead of using the classical modifier style where repeated `btn` creating redundancy as below:

```html
<!-- not to be used -->
<button class="o-btn o-btn--warning o-btn--large o-btn--round">
```

We will be using chaining modifiers. Where modifiers are denoted by a leading (-) hyphen. So our HTML would be become:

```html
<button class="o-btn--warning -size-large -border-round">
```

Our SASS structure would become:

```css
.o-btn {
  &.-large {...}
  &.-round {...}
  &.-icon {...}
}
.o-btn--warning {
  @extend .o-btn;
  ...
}
```
**Chainable Modifiers Rules**
1. Chainable modifiers should never modify the same property twice e.g. 2 more more chained modifiers change the color rule should not happen
2. Use a namespace which describe the change e.g. size, color & width etc
3. Use generic descriptors e.g. large, primary & dark etc

### Directory Structure
For SASS directory structure we will be using flat structure as provided in [BEM Flat Directory structure](https://en.bem.info/methodology/filestructure/#flat). For example:
```
project
    common.blocks/
        input_type_search.css     # The input_type_search modifier in CSS
        input.css
        popup.css
```

### References
Some handy reads links below would give better understanding of what is summarized below:

- [csswizardry](https://csswizardry.com/2015/03/more-transparent-ui-code-with-namespaces/)
- [smashingmagazine](https://www.smashingmagazine.com/2016/06/battling-bem-extended-edition-common-problems-and-how-to-avoid-them/)
- [Writing Modular BEM Part 1](https://zellwk.com/blog/css-architecture-1/)
- [Writing Modular BEM Part 2](https://zellwk.com/blog/css-architecture-2/)
- [Sassier BEM Modifiers](https://www.viget.com/articles/bem-sass-modifiers/)
- [SMACSS](https://smacss.com/)

**Screencasts**
- [BEVM](https://www.youtube.com/watch?v=nwS7M2L07uU)
- [Modular CSS](https://www.youtube.com/watch?v=Ty5jtMZXbmk)
- [MindBEMding](https://www.youtube.com/watch?v=vgg-NsKZaE4&t=1881s)
